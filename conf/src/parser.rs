//! Parser implementation to parse the simple
//! conf syntax for core lightning conf file
use crate::{
    file::{File, SyncFile},
    CLNConf, ParsingError, SyncCLNConf,
};
use albert_stream::{BasicStream, Stream};

pub struct Parser {
    file: File,
    create_if_missing: bool,
}

type Word = String;

impl Parser {
    pub(crate) fn new(file_path: &str, create_if_missing: bool) -> Self {
        Parser {
            file: File::new(file_path),
            create_if_missing,
        }
    }

    fn read_and_split(&self) -> Result<Vec<Word>, ParsingError> {
        let content = if !self.file.exist() && self.create_if_missing {
            self.file.write(
                "# core lightning configuration generated by coffe please do not edit this",
            )?;
            self.file.read()
        } else {
            self.file.read()
        }?;

        let lines: Vec<String> = content
            .split('\n')
            .filter(|it| !it.is_empty())
            .map(|it| it.to_string())
            .collect();
        let mut words = vec![];
        for line in lines {
            if line.starts_with("#") {
                continue;
            }
            if line.starts_with("include") {
                words.push(line);
                continue;
            }
            let mut key_val: Vec<String> = line.split('=').map(|it| it.to_string()).collect();
            words.append(&mut key_val);
        }

        Ok(words)
    }

    pub fn parse(&self, conf: &mut CLNConf) -> Result<(), ParsingError> {
        let words = self.read_and_split()?;
        let mut stream = BasicStream::<Word>::new(&words);
        self.parse_stream(&mut stream, conf)
    }

    fn parse_stream(
        &self,
        stream: &mut BasicStream<Word>,
        conf: &mut CLNConf,
    ) -> Result<(), ParsingError> {
        while !stream.is_end() {
            self.parse_key_value(stream, conf)?;
        }
        Ok(())
    }

    fn parse_key_value(
        &self,
        stream: &mut BasicStream<Word>,
        conf: &mut CLNConf,
    ) -> Result<(), ParsingError> {
        let key = stream.advance().to_owned();
        if key.starts_with("include") {
            let value = key.strip_prefix("include ").unwrap().trim();
            let mut subconf = CLNConf::new(value.to_owned(), false);
            if let Err(err) = subconf.parse() {
                return Err(err);
            }
            conf.add_subconf(subconf);
        } else {
            let value = stream.advance().to_owned();
            conf.add_conf(&key, &value);
        }
        Ok(())
    }
}
